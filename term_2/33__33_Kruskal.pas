{Задается неориентированный взвешенный полный граф.
Простая программа нахождения кратчайших ребер от каждой вершины (построения 
остовного графа, (алгоритм Крускала), для справки: в остовном дереве количество 
ребер на 1 меньше количества вершин.)  в сгенерированном полном взвешенном 
неориентированном графе и выводом матрицы смежности (представленной динамическим
 массивом) и конечных вершин ребер с указанием веса ребер (веса конечной вершины). 
(В качестве альтернативы матрицу смежности можно задавать статическим массивом, 
неполный граф можно моделировать дополнительной рандомизацией по удалению 
некоторых ребер, можно матрицу смежности для произвольного графа читать из файла
 и т.п.)}

program  Graph_Min_Path; 

type
  TNetwork = array of array of  integer;  {Тип двумерного динамического массива 
                                           для матрицы смежности графа}
  TLines = array of  array[1..2] of  integer; {Тип двумерного динамического 
                                            массива для матрицы найденных путей}

var
  dis: TNetwork;
  res: TLines;
  i, j, n, len: integer;

procedure Create_Graph(var dis: TNetwork; N:integer); {Создание матрицы 
                             смежности в виде двумерного динамического массива}
var
  i, j: integer;
begin
  setlength(dis, N); {Установление длины (размерности) матрицы по числу 
                      подматриц (по числу строк)  матрицы dis – длина 
                      устанавливается по первому индексу}
  for i:=0 to N-1 do
    setlength(dis[i], N); {Установление длины (размерности) каждой подматрицы 
                           по числу ее элементов в матрице dis}
  randomize;
  for i := 0 to N-1 do
  begin
    for j := i to N-1 do
      if (i = j) then dis[i, j] := 0 {Заполнение диагонали матрицы dis}
        else  
      begin
        dis[i, j] := (random(100)); {Генерирование ненулевых длин (весов) ребер}
        dis[j, i] := dis[i, j]; {Симметричное заполнение матрицы dis, т.к. граф 
                                 неориентированный }
      end;
  end;
end;

procedure Write_Graph(dis: TNetwork); {Вывод  матрицы смежности }
var
  i, j: integer;
begin
  for i := 0 to length(dis)-1 do
  begin
    for j := 0 to length(dis)-1 do
      write(dis[i, j]:4);
    writeln;
  end;
end;

procedure Min_Edge (dis: TNetwork; var res: TLines); {Нахождение минимальных 
                                                      ребер для всех вершин }
var
  i, j: integer;
  colors: array of  integer;
  min, k, l, r, color, N: integer;
begin
  k := 0;  {Количество найденных ребер}
  len := 0;  {Длина (вес) ребра}
  N:=length(dis);
  setlength(colors, N);
  setlength(res, N);
  for i := 0 to N-1 do
    colors[i] := i; {Раскраска вершин их номером для проверки безопасности 
                     вершин, т.е. какие вершины можно включать (соединять) чтобы 
                     не было циклов}
  while k < N - 1 do {Цикл по количеству найденных минимальных ребер, их должно 
                     быть на 1 меньше чем количество вершин}
  begin
    min := 32767; {Заданное предельно большое число для веса ребра }
    l := 0;
    r := 1;
    for i := 0 to N - 2 do {Цикл по перебору начальных вершин}
      for j := i + 1 to N-1 do     {Цикл по перебору конечных вершин}   
        if (dis[i, j] < min) and (colors[i] <> colors[j]) then
        begin
          min := dis[i, j];    {Нахождение минимального допустимого ребра}
          l := i;
          r := j;            {Координаты найденного минимального ребра}
        end;
    k:=k+1;  {Подсчет  количества найденных минимальных ребер}
    len:=len + min;  {Накапливание общего веса минимального остовного графа}    
    res[k-1][1]:=l;
    res[k-1][2]:=r; {Формирование координат найденного ребра в выходном массиве 
                     результатов}
    color:=colors[l];  {Цвет начальной вершины включенного ребра для проверки 
                       на допустимость (безопасность) смежных для ребра вершин }
    for i:=0 to N-1 do 
      if (colors[i]=color) then 
        colors[i]:=colors[r]; {Перебором цветов вершин определяем, если цвет 
                              начальной вершины найденного минимального ребра 
                              повторился для какой-то вершины, то эту вершину 
                              красим в цвет конечной вершины уже найденного 
                              ребра (таким образом, если между ними существует 
                              ребро, то обе его вершины будут покрашены в один 
                              цвет – цвет конечной вершины найденного ребра, и 
                              из дальнейшего рассмотрения исключаются, согласно 
                              условию, что обе вершины минимального ребра должны 
                              иметь разный цвет (см. выше). Тем самым мы 
                              избегаем рассмотрения минимальных ребер, 
                              образующих циклы}
  end;
end;

procedure Write_Edge (res:TLines; dis:TNetwork); {Вывод найденных ребер с 
                        указанием начальной и конечной вершины ребра и его веса}
var 
  i,j:integer; 
 begin
  for i:=0 to length(dis)-2 do
    writeln(res[i][1]+1, '<---->', res[i][2]+1, ' вес ребра ', 
            dis[res[i][1],res[i][2]]);
    writeln(' Минимальный вес остовного дерева =   ', len);
  end;  


begin
  writeln('Введите количество узлов графа');
  readln(n);
  Create_Graph(dis, n);
  Write_Graph(dis);
  Min_Edge(dis, res);
  Write_Edge(res, dis);
end.
{Дополнительно. Вывести полученное остовное дерево в виде матрицы смежности}
